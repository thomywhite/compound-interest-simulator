<!doctype html>
<html lang="fr" class="h-full">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simulateur d’intérêt composé</title>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = { darkMode: 'class' }
  </script>
  <style>
    :focus-visible { outline: 2px solid #2563eb; outline-offset: 2px; }
    html, body, #root { height: 100%; }
  </style>

  <!-- Babel runtime so JSX compiles in the browser -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- UMD globals (no imports, no bundler) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/framer-motion@11/dist/framer-motion.umd.js"></script>
  <script src="https://unpkg.com/decimal.js@10.4.3/decimal.js"></script>
  <script src="https://unpkg.com/recharts@2/umd/Recharts.js"></script>
</head>
<body class="min-h-full bg-slate-50 text-slate-900 dark:bg-slate-950 dark:text-slate-100">
  <div id="root"></div>

  <!-- Your app, compiled by Babel at runtime -->
  <script type="text/babel">
    // Grab UMD globals
    const { useEffect, useMemo, useState, useRef } = React;
    const { createRoot } = ReactDOM; // React 18 UMD exposes createRoot
    const { motion, AnimatePresence } = window.framerMotion || {};
    const {
      ResponsiveContainer, AreaChart, Area, BarChart, Bar,
      XAxis, YAxis, Tooltip, Legend, CartesianGrid
    } = Recharts;
    const DecimalJS = window.Decimal;

    // --- i18n (FR default) ---
    const dict = {
      fr: {
        title: "Simulateur d’intérêt composé",
        modeTabs: ["Combien j’aurai ?", "Combien de temps ?", "Quelle contribution ?"],
        frequency: "Fréquence",
        contribution: "Contribution",
        compounding: "Capitalisation",
        daily: "Quotidienne", weekly: "Hebdomadaire", monthly: "Mensuelle", yearly: "Annuelle",
        inputs: {
          p0: "Montant initial (P0)",
          pmt: "Contribution par période (PMT)",
          rate: "Rendement annuel nominal (r%)",
          fee: "Frais annuels (fee%)",
          infl: "Inflation (infl%)",
          horizon: "Horizon",
          years: "années", months: "mois",
          target: "Cible (FV)",
          timing: "Moment de la contribution",
          start: "Début de période", end: "Fin de période",
          taxes: "Afficher les taxes (à venir)"
        },
        outputs: {
          final: "Solde final / cible",
          contrib: "Total des contributions",
          growth: "Total de croissance",
          ear: "Taux effectif annuel (après frais)",
          real: "Solde réel (inflation)"
        },
        charts: {
          balanceOverTime: "Solde dans le temps",
          breakdown: "Décomposition (contributions vs croissance)",
          totals: "Totaux"
        },
        presets: "Préréglages",
        presetOptions: [
          {key:'lump', label:'Versement unique'},
          {key:'monthly', label:'Contributions mensuelles'},
          {key:'aggressive', label:'Agressif (rendement élevé)'}
        ],
        actions: { reset:'Réinitialiser', copy:'Copier le lien', csv:'Exporter CSV' },
        state: { copied:'Lien copié' },
        unreachable: "Cible inatteignable avec ces paramètres.",
        suggestion: "Augmentez la contribution, l’horizon, ou le rendement.",
        timeToGoal: (y,m) => `Durée estimée: ${y} an(s) ${m} mois`,
        requiredPMT: (val,cur) => `Contribution requise: ${cur}${fmt(val)}/période`,
        language:'Langue', currency:'Devise', theme:'Thème', light:'Clair', dark:'Sombre'
      },
      en: {
        title: "Compound Interest Simulator",
        modeTabs: ["How much will I have?","How long will it take?","How much should I contribute?"],
        frequency: "Frequency",
        contribution: "Contribution",
        compounding: "Compounding",
        daily: "Daily", weekly: "Weekly", monthly: "Monthly", yearly: "Annually",
        inputs: {
          p0: "Initial amount (P0)",
          pmt: "Contribution per period (PMT)",
          rate: "Annual nominal return (r%)",
          fee: "Annual fees (fee%)",
          infl: "Inflation (infl%)",
          horizon: "Horizon",
          years: "years", months: "months",
          target: "Target (FV)",
          timing: "Contribution timing",
          start: "Start of period", end: "End of period",
          taxes: "Show taxes (placeholder)"
        },
        outputs: {
          final: "Final/Target balance",
          contrib: "Total contributions",
          growth: "Total growth",
          ear: "Effective annual rate (after fees)",
          real: "Real balance (inflation)"
        },
        charts: {
          balanceOverTime: "Balance over time",
          breakdown: "Breakdown (contrib vs growth)",
          totals: "Totals"
        },
        presets: "Presets",
        presetOptions: [
          {key:'lump', label:'Lump sum only'},
          {key:'monthly', label:'Monthly contributions'},
          {key:'aggressive', label:'Aggressive (higher return)'}
        ],
        actions: { reset:'Reset', copy:'Copy link', csv:'Export CSV' },
        state: { copied:'Link copied' },
        unreachable: "Target is unreachable with these parameters.",
        suggestion: "Try a higher contribution, longer horizon, or higher return.",
        timeToGoal: (y,m) => `Estimated duration: ${y} year(s) ${m} month(s)`,
        requiredPMT: (val,cur) => `Required contribution: ${cur}${fmt(val)}/period`,
        language:'Language', currency:'Currency', theme:'Theme', light:'Light', dark:'Dark'
      }
    };

    // --- utils ---
    const clamp = (v,min,max)=>Math.min(Math.max(v,min),max);
    const fmt = (n)=> new Intl.NumberFormat(undefined,{maximumFractionDigits:2}).format(Number(n));
    const currencyFmt = (n, sym)=> `${sym}${fmt(n)}`;
    const FREQ = { daily:365, weekly:52, monthly:12, yearly:1 };

    const DEFAULTS = {
      mode:'fv', lang:'fr', currency:'$', theme:'auto',
      p0:10000, pmt:200, rate:7, fee:0.5, infl:2, years:20, months:0,
      target:100000, contribFreq:'monthly', compFreq:'monthly', timing:'end',
      showTaxes:false
    };

    function readStateFromURL(){
      const p = new URLSearchParams(location.search);
      const get = (k, d)=> p.get(k) ?? d;
      const num = (k, d)=> p.has(k) ? Number(p.get(k)) : d;
      const bool = (k, d)=> p.has(k) ? (p.get(k)==='1'||p.get(k)==='true') : d;
      return {
        mode:get('mode',DEFAULTS.mode),
        lang:get('lang',DEFAULTS.lang),
        currency:get('cur',DEFAULTS.currency),
        theme:get('theme',DEFAULTS.theme),
        p0:num('p0',DEFAULTS.p0),
        pmt:num('pmt',DEFAULTS.pmt),
        rate:num('r',DEFAULTS.rate),
        fee:num('fee',DEFAULTS.fee),
        infl:num('infl',DEFAULTS.infl),
        years:num('y',DEFAULTS.years),
        months:num('m',DEFAULTS.months),
        target:num('tgt',DEFAULTS.target),
        contribFreq:get('cf',DEFAULTS.contribFreq),
        compFreq:get('pf',DEFAULTS.compFreq),
        timing:get('tim',DEFAULTS.timing),
        showTaxes:bool('tax',DEFAULTS.showTaxes)
      };
    }
    function writeStateToURL(s){
      const p = new URLSearchParams();
      p.set('mode',s.mode); p.set('lang',s.lang); p.set('theme',s.theme); p.set('cur',s.currency);
      p.set('p0',s.p0); p.set('pmt',s.pmt); p.set('r',s.rate); p.set('fee',s.fee); p.set('infl',s.infl);
      p.set('y',s.years); p.set('m',s.months); p.set('tgt',s.target); p.set('cf',s.contribFreq);
      p.set('pf',s.compFreq); p.set('tim',s.timing); p.set('tax',s.showTaxes?'1':'0');
      history.replaceState(null,'',`${location.pathname}?${p.toString()}`);
    }

    // finance math
    function netNominal(rPct,fPct){
      const r = new DecimalJS(rPct).div(100);
      const f = new DecimalJS(fPct).div(100);
      return r.plus(1).div(f.plus(1)).minus(1);
    }
    function earAfterFees(rPct,fPct, compKey){
      const rNet = netNominal(rPct,fPct);
      const m = new DecimalJS(FREQ[compKey]);
      return rNet.div(m).plus(1).pow(m).minus(1);
    }
    function simulate({p0,pmt,ratePct,feePct,inflPct,years,months,compFreqKey,contribFreqKey,timing}){
      const totalYears = new DecimalJS(years).plus(new DecimalJS(months).div(12));
      const rNet = netNominal(ratePct,feePct);
      const mComp = new DecimalJS(FREQ[compFreqKey]);
      const mContrib = new DecimalJS(FREQ[contribFreqKey]);
      const mStep = DecimalJS.max(mComp,mContrib);
      const dt = new DecimalJS(1).div(mStep);
      const steps = DecimalJS.ceil(totalYears.times(mStep)).toNumber();
      const iComp = rNet.div(mComp);

      let balance = new DecimalJS(p0);
      let contributed = new DecimalJS(0);
      let growth = new DecimalJS(0);
      let compCounter = new DecimalJS(0);
      let contribCounter = new DecimalJS(0);
      const data = [];

      for (let s=0; s<=steps; s++){
        const tYears = new DecimalJS(s).times(dt);
        const realAdj = new DecimalJS(1).plus(new DecimalJS(inflPct).div(100)).pow(tYears);
        const realBal = realAdj.eq(0) ? balance : balance.div(realAdj);
        data.push({
          step:s, tYears:Number(tYears), balance:Number(balance),
          contributed:Number(contributed),
          growth:Number(balance.minus(contributed).minus(p0)),
          realBalance:Number(realBal)
        });
        if (s===steps) break;

        compCounter = compCounter.plus(mComp.div(mStep));
        contribCounter = contribCounter.plus(mContrib.div(mStep));
        const compEvents = compCounter.floor().toNumber();
        const contribEvents = contribCounter.floor().toNumber();

        if (contribEvents>0 && timing==='start'){
          const add = new DecimalJS(pmt).times(contribEvents);
          balance=balance.plus(add); contributed=contributed.plus(add);
          contribCounter=contribCounter.minus(contribEvents);
        }
        if (compEvents>0){
          for (let k=0;k<compEvents;k++){
            const before=balance; balance=balance.times(iComp.plus(1));
            growth=growth.plus(balance.minus(before));
          }
          compCounter=compCounter.minus(compEvents);
        }
        if (contribEvents>0 && timing==='end'){
          const add = new DecimalJS(pmt).times(contribEvents);
          balance=balance.plus(add); contributed=contributed.plus(add);
          contribCounter=contribCounter.minus(contribEvents);
        }
      }
      const final = balance;
      const totalContrib = contributed;
      const totalGrowth = final.minus(totalContrib).minus(p0);
      const realFinal = data[data.length-1].realBalance;
      return { final, totalContrib, totalGrowth, realFinal, data, ear: earAfterFees(ratePct,feePct,compFreqKey) };
    }
    function timeToGoalSim(params){
      const maxYears=100;
      const target = new DecimalJS(params.target);
      const rNet = netNominal(params.ratePct, params.feePct);
      const mComp = new DecimalJS(FREQ[params.compFreqKey]);
      const mContrib = new DecimalJS(FREQ[params.contribFreqKey]);
      const mStep = DecimalJS.max(mComp, mContrib);
      const iComp = rNet.div(mComp);
      let balance = new DecimalJS(params.p0);
      let contributed = new DecimalJS(0);
      let compCounter=new DecimalJS(0), contribCounter=new DecimalJS(0);
      let steps=0, maxSteps=mStep.times(maxYears).toNumber();
      for (; steps<=maxSteps; steps++){
        if (balance.gte(target)) break;
        compCounter=compCounter.plus(mComp.div(mStep));
        contribCounter=contribCounter.plus(mContrib.div(mStep));
        const compEvents=compCounter.floor().toNumber();
        const contribEvents=contribCounter.floor().toNumber();
        if (contribEvents>0 && params.timing==='start'){
          const add=new DecimalJS(params.pmt).times(contribEvents);
          balance=balance.plus(add); contributed=contributed.plus(add);
          contribCounter=contribCounter.minus(contribEvents);
        }
        if (compEvents>0){
          for (let k=0;k<compEvents;k++){ balance=balance.times(iComp.plus(1)); }
          compCounter=compCounter.minus(compEvents);
        }
        if (contribEvents>0 && params.timing==='end'){
          const add=new DecimalJS(params.pmt).times(contribEvents);
          balance=balance.plus(add); contributed=contributed.plus(add);
          contribCounter=contribCounter.minus(contribEvents);
        }
      }
      if (steps>maxSteps) return { reachable:false, years:maxYears, months:0 };
      const tYears = new DecimalJS(steps).div(mStep);
      const years=tYears.floor(); const months=tYears.minus(years).times(12).round();
      return { reachable:true, years:years.toNumber(), months:months.toNumber(), tYears:tYears.toNumber() };
    }
    function requiredPMTByBisection(params){
      const { p0, ratePct, feePct, inflPct, years, months, compFreqKey, contribFreqKey, timing, target } = params;
      const horizonYears = new DecimalJS(years).plus(new DecimalJS(months).div(12));
      const simulateWith = PMT => simulate({
        p0, pmt:PMT, ratePct, feePct, inflPct,
        years:horizonYears.toNumber(), months:0,
        compFreqKey, contribFreqKey, timing
      }).final;
      let lo=new DecimalJS(0), hi=new DecimalJS(target).times(2).plus(1000);
      for (let i=0;i<30;i++){ const fv=simulateWith(hi); if (fv.gte(target)) break; hi=hi.times(2); }
      for (let it=0; it<60; it++){
        const mid=lo.plus(hi).div(2); const fv=simulateWith(mid);
        if (fv.gte(target)) hi=mid; else lo=mid;
      }
      return hi;
    }
    function exportCSV(rows, filename='simulation.csv'){
      const header = ['step','years','balance','contributed','growth','real_balance'];
      const lines = [header.join(',')];
      for (const r of rows){
        lines.push([r.step,r.tYears,r.balance,r.contributed,r.growth,r.realBalance].join(','));
      }
      const blob=new Blob([lines.join('\n')],{type:'text/csv'});
      const url=URL.createObjectURL(blob); const a=document.createElement('a');
      a.href=url; a.download=filename; a.click(); URL.revokeObjectURL(url);
    }

    // simple UI components (no icon lib)
    const Card = ({children}) =>
      <div className="rounded-2xl bg-white dark:bg-slate-900 ring-1 ring-slate-200 dark:ring-slate-800 shadow p-4">{children}</div>;
    const KPI = ({label,value}) =>
      <div className="flex flex-col"><span className="text-xs text-slate-500 uppercase">{label}</span><span className="text-xl font-semibold">{value}</span></div>;

    const Segmented = ({ options, value, onChange, label }) =>
      <div className="flex flex-col gap-2">
        {label && <label className="text-sm text-slate-600 dark:text-slate-300">{label}</label>}
        <div role="tablist" className="inline-flex rounded-xl bg-white dark:bg-slate-900 shadow ring-1 ring-slate-200 dark:ring-slate-800 overflow-hidden">
          {options.map(opt =>
            <button key={opt.value} role="tab" aria-selected={value===opt.value}
              className={(value===opt.value?'bg-slate-900 text-white dark:bg-slate-100 dark:text-slate-900':'text-slate-700 dark:text-slate-200')+' px-3 py-1.5 text-sm'}
              onClick={()=>onChange(opt.value)}>{opt.label}</button>
          )}
        </div>
      </div>;

    function NumberInput({ id, label, value, onChange, step=1, min=0, max=1e9, suffix, slider=false }){
      const [local,setLocal] = useState(String(value));
      useEffect(()=>setLocal(String(value)),[value]);
      useEffect(()=>{ const t=setTimeout(()=>{ const n=Number(local); if(!Number.isNaN(n)) onChange(clamp(n,min,max)); },300); return ()=>clearTimeout(t); },[local]);
      return (
        <div className="flex flex-col gap-1">
          <label htmlFor={id} className="text-sm text-slate-600 dark:text-slate-300">{label}</label>
          <div className="flex items-center gap-2">
            <input id={id} type="number" inputMode="decimal" value={local}
              onChange={e=>setLocal(e.target.value)} step={step} min={min} max={max}
              className="w-full rounded-lg border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-900 px-3 py-2 text-sm"/>
            {suffix && <span className="text-sm text-slate-500">{suffix}</span>}
          </div>
          {slider && <input type="range" min={min} max={max} step={step} value={value} aria-label={label} onChange={e=>onChange(Number(e.target.value))} className="w-full"/>}
        </div>
      );
    }
    const Switch = ({checked,onChange,label,id}) =>
      <div className="flex items-center justify-between">
        <label htmlFor={id} className="text-sm text-slate-600 dark:text-slate-300">{label}</label>
        <button id={id} role="switch" aria-checked={checked} onClick={()=>onChange(!checked)}
          className={(checked?'bg-emerald-600':'bg-slate-300 dark:bg-slate-700')+' relative inline-flex h-6 w-11 items-center rounded-full transition-colors'}>
          <span className={(checked?'translate-x-6':'translate-x-1')+' inline-block h-4 w-4 transform rounded-full bg-white'}></span>
        </button>
      </div>;

    function ChartsPanel({series, t, currency}){
      const money = v => currencyFmt(v, currency);
      const yearsTick = v => `${fmt(v)}`;
      return (
        <div className="grid gap-4">
          <Card>
            <h3 className="text-sm font-medium mb-2">{t.balanceOverTime}</h3>
            <div className="h-64">
              <ResponsiveContainer width="100%" height="100%">
                <AreaChart data={series} margin={{ top: 10, right: 20, left: 0, bottom: 0 }}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="tYears" tickFormatter={yearsTick} label={{ value: 'années / years', position: 'insideBottom', dy: 10 }} />
                  <YAxis tickFormatter={money} width={80} />
                  <Tooltip formatter={(value, name) => [money(value), name]} labelFormatter={(l)=>`${fmt(l)} ans`} />
                  <Area type="monotone" dataKey="balance" strokeWidth={2} fillOpacity={0.2} fill="url(#g1)" stroke="#2563eb" name="Solde / Balance"/>
                  <defs>
                    <linearGradient id="g1" x1="0" y1="0" x2="0" y2="1">
                      <stop offset="5%" stopOpacity={0.3}/><stop offset="95%" stopOpacity={0}/>
                    </linearGradient>
                  </defs>
                </AreaChart>
              </ResponsiveContainer>
            </div>
          </Card>
          <Card>
            <h3 className="text-sm font-medium mb-2">{t.breakdown}</h3>
            <div className="h-64">
              <ResponsiveContainer width="100%" height="100%">
                <AreaChart data={series}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="tYears" tickFormatter={yearsTick} />
                  <YAxis tickFormatter={money} width={80} />
                  <Tooltip formatter={v=>money(v)} />
                  <Area type="monotone" dataKey="contributed" stackId="1" stroke="#0ea5e9" fillOpacity={0.2} name="Contributions" />
                  <Area type="monotone" dataKey={d=>Math.max(0, d.balance - d.contributed)} stackId="1" stroke="#22c55e" fillOpacity={0.2} name="Croissance / Growth" />
                </AreaChart>
              </ResponsiveContainer>
            </div>
          </Card>
          <Card>
            <h3 className="text-sm font-medium mb-2">{t.totals}</h3>
            <div className="h-56">
              <ResponsiveContainer width="100%" height="100%">
                <BarChart data={[series[series.length-1]]}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="tYears" tickFormatter={()=>''} />
                  <YAxis tickFormatter={money} width={80} />
                  <Tooltip formatter={money} />
                  <Legend />
                  <Bar dataKey="contributed" name="Contributions" />
                  <Bar dataKey={d=>Math.max(0, d.balance - d.contributed)} name="Croissance / Growth" />
                </BarChart>
              </ResponsiveContainer>
            </div>
          </Card>
        </div>
      );
    }

    function App(){
      const [state, setState] = useState(readStateFromURL());
      const t = dict[state.lang] ?? dict.fr;
      useEffect(()=>writeStateToURL(state),[state]);

      const horizonYears = useMemo(()=> new DecimalJS(state.years).plus(new DecimalJS(state.months).div(12)).toNumber(), [state.years, state.months]);

      const simParams = useMemo(()=>({
        p0:state.p0, pmt:state.pmt, ratePct:state.rate, feePct:state.fee, inflPct:state.infl,
        years: state.mode==='time' ? 1 : horizonYears, months:0,
        compFreqKey:state.compFreq, contribFreqKey:state.contribFreq, timing:state.timing
      }), [state, horizonYears]);

      const sim = useMemo(()=> simulate(simParams), [simParams]);

      const timeResult = useMemo(()=>{
        if (state.mode!=='time') return null;
        return timeToGoalSim({
          p0:state.p0, pmt:state.pmt, ratePct:state.rate, feePct:state.fee,
          contribFreqKey:state.contribFreq, compFreqKey:state.compFreq, timing:state.timing,
          target:state.target
        });
      }, [state]);

      const requiredPMT = useMemo(()=>{
        if (state.mode!=='pmt') return null;
        return requiredPMTByBisection({
          p0:state.p0, ratePct:state.rate, feePct:state.fee, inflPct:state.infl,
          years:state.years, months:state.months, compFreqKey:state.compFreq, contribFreqKey:state.contribFreq,
          timing:state.timing, target:state.target
        }).toNumber();
      }, [state]);

      useEffect(()=>{
        const btn=document.getElementById('csv-btn'); if(!btn) return;
        const h=()=>exportCSV(sim.data); btn.addEventListener('click',h); return()=>btn.removeEventListener('click',h);
      }, [sim]);

      const earPct = sim.ear.times(100).toNumber();
      const k1 = (state.mode==='time') ? currencyFmt(state.target, state.currency) : currencyFmt(sim.final, state.currency);
      const k2 = currencyFmt(sim.totalContrib, state.currency);
      const k3 = currencyFmt(sim.totalGrowth, state.currency);
      const k4 = `${fmt(earPct)}%`;
      const k5 = currencyFmt(sim.realFinal, state.currency);

      const freqOpts = [
        {value:'daily', label:t.daily},
        {value:'weekly', label:t.weekly},
        {value:'monthly', label:t.monthly},
        {value:'yearly', label:t.yearly}
      ];

      return (
        <main className="mx-auto max-w-7xl px-4 pb-8">
          <div className="flex items-center justify-between py-4">
            <h1 className="text-xl font-semibold">{t.title}</h1>
            <div className="flex items-center gap-3">
              <div className="flex items-center gap-2">
                <span className="text-sm text-slate-600 dark:text-slate-300">{t.language}</span>
                <select aria-label={t.language} value={state.lang} onChange={e=>setState(s=>({...s, lang:e.target.value}))}
                  className="rounded-md border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-900 px-2 py-1 text-sm">
                  <option value="fr">FR</option><option value="en">EN</option>
                </select>
              </div>
              <div className="flex items-center gap-2">
                <span className="text-sm text-slate-600 dark:text-slate-300">{t.currency}</span>
                <select aria-label={t.currency} value={state.currency} onChange={e=>setState(s=>({...s, currency:e.target.value}))}
                  className="rounded-md border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-900 px-2 py-1 text-sm">
                  <option value="$">$</option><option value="€">€</option><option value="CA$">CA$</option>
                </select>
              </div>
            </div>
          </div>

          {/* Controls */}
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <section aria-label="Paramètres">
              <div className="grid gap-4">
                <div className="flex gap-2" role="tablist" aria-label="Modes">
                  {[
                    {key:'fv', label:t.modeTabs[0]},
                    {key:'time', label:t.modeTabs[1]},
                    {key:'pmt', label:t.modeTabs[2]}
                  ].map(tab =>
                    <button key={tab.key} role="tab" aria-selected={state.mode===tab.key}
                      onClick={()=>setState(s=>({...s, mode:tab.key}))}
                      className={(state.mode===tab.key?'bg-slate-900 text-white dark:bg-slate-100 dark:text-slate-900':'bg-white dark:bg-slate-900 text-slate-700 dark:text-slate-200')+' px-3 py-1.5 rounded-lg ring-1 ring-slate-200 dark:ring-slate-800'}>
                      {tab.label}
                    </button>
                  )}
                </div>

                <Card>
                  <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <NumberInput id="p0" label={t.inputs.p0} value={state.p0} onChange={v=>setState(s=>({...s, p0:v}))} min={0} step={100} slider/>
                    {state.mode!=='time' &&
                      <NumberInput id="pmt" label={t.inputs.pmt} value={state.pmt} onChange={v=>setState(s=>({...s, pmt:v}))} min={0} step={10} slider/>}
                    <NumberInput id="rate" label={t.inputs.rate} value={state.rate} onChange={v=>setState(s=>({...s, rate:v}))} min={-50} max={100} step={0.1} suffix="%" slider/>
                    <NumberInput id="fee" label={t.inputs.fee} value={state.fee} onChange={v=>setState(s=>({...s, fee:v}))} min={0} max={10} step={0.1} suffix="%" slider/>
                    <NumberInput id="infl" label={t.inputs.infl} value={state.infl} onChange={v=>setState(s=>({...s, infl:v}))} min={0} max={20} step={0.1} suffix="%" slider/>
                    {state.mode!=='time' &&
                      <div className="grid grid-cols-2 gap-3">
                        <NumberInput id="years" label={t.inputs.years} value={state.years} onChange={v=>setState(s=>({...s, years:v}))} min={0} max={120} step={1}/>
                        <NumberInput id="months" label={t.inputs.months} value={state.months} onChange={v=>setState(s=>({...s, months:v}))} min={0} max={11} step={1}/>
                      </div>}
                    {state.mode!=='fv' &&
                      <NumberInput id="target" label={t.inputs.target} value={state.target} onChange={v=>setState(s=>({...s, target:v}))} min={0} step={100} slider/>}

                    <Segmented label={`${t.frequency} – ${t.contribution}`} value={state.contribFreq}
                      onChange={v=>setState(s=>({...s, contribFreq:v}))}
                      options={freqOpts}/>
                    <Segmented label={`${t.frequency} – ${t.compounding}`} value={state.compFreq}
                      onChange={v=>setState(s=>({...s, compFreq:v}))}
                      options={freqOpts}/>
                    <Segmented label={t.inputs.timing} value={state.timing}
                      onChange={v=>setState(s=>({...s, timing:v}))}
                      options={[{value:'start',label:t.inputs.start},{value:'end',label:t.inputs.end}]}/>
                    <Switch id="taxes" checked={state.showTaxes} onChange={v=>setState(s=>({...s, showTaxes:v}))} label={t.inputs.taxes}/>
                  </div>
                </Card>

                <div className="flex items-center gap-3">
                  <label className="text-sm text-slate-600 dark:text-slate-300">{t.presets}</label>
                  <select onChange={e=>{
                    const key=e.target.value;
                    if (key==='lump') setState(s=>({...s, p0:10000,pmt:0,rate:7,fee:0.5,infl:2,years:20,months:0,contribFreq:'monthly',compFreq:'monthly'}));
                    if (key==='monthly') setState(s=>({...s, p0:10000,pmt:200,rate:7,fee:0.5,infl:2,years:20,months:0,contribFreq:'monthly',compFreq:'monthly'}));
                    if (key==='aggressive') setState(s=>({...s, p0:10000,pmt:300,rate:10,fee:0.3,infl:2,years:25,months:0,contribFreq:'weekly',compFreq:'monthly'}));
                  }} defaultValue="">
                    <option value="" disabled>—</option>
                    {t.presetOptions.map(p=><option key={p.key} value={p.key}>{p.label}</option>)}
                  </select>
                  <button className="ml-auto inline-flex items-center gap-2 px-3 py-1.5 rounded-lg ring-1 ring-slate-200 dark:ring-slate-800 bg-white dark:bg-slate-900"
                          onClick={()=>setState(prev=>({...DEFAULTS, lang:prev.lang, currency:prev.currency}))}>
                    {dict[state.lang].actions.reset}
                  </button>
                  <button className="inline-flex items-center gap-2 px-3 py-1.5 rounded-lg ring-1 ring-slate-200 dark:ring-slate-800 bg-white dark:bg-slate-900"
                          onClick={()=>{ navigator.clipboard.writeText(location.href).then(()=>{ const m=document.getElementById('copied-msg'); if(m){ m.textContent=dict[state.lang].state.copied; setTimeout(()=>m.textContent='',1500); } }); }}>
                    {dict[state.lang].actions.copy}
                  </button>
                  <span id="copied-msg" className="text-sm text-emerald-600"></span>
                  <button className="inline-flex items-center gap-2 px-3 py-1.5 rounded-lg ring-1 ring-slate-200 dark:ring-slate-800 bg-white dark:bg-slate-900" id="csv-btn">
                    {dict[state.lang].actions.csv}
                  </button>
                </div>
              </div>
            </section>

            <section aria-label="Résultats" className="grid gap-4">
              <div className="grid grid-cols-2 md:grid-cols-5 gap-3">
                <Card><KPI label={dict[state.lang].outputs.final} value={ (state.mode==='time') ? currencyFmt(state.target, state.currency) : currencyFmt(sim.final, state.currency) }/></Card>
                <Card><KPI label={dict[state.lang].outputs.contrib} value={currencyFmt(sim.totalContrib, state.currency)}/></Card>
                <Card><KPI label={dict[state.lang].outputs.growth} value={currencyFmt(sim.totalGrowth, state.currency)}/></Card>
                <Card><KPI label={dict[state.lang].outputs.ear} value={`${fmt(sim.ear.times(100).toNumber())}%`}/></Card>
                <Card><KPI label={dict[state.lang].outputs.real} value={currencyFmt(sim.realFinal, state.currency)}/></Card>
              </div>

              {state.mode==='time' &&
                <Card>
                  {timeResult?.reachable
                    ? <p className="text-sm">{dict[state.lang].timeToGoal(timeResult.years, timeResult.months)}</p>
                    : <><p className="text-sm text-rose-600">{dict[state.lang].unreachable}</p><p className="text-sm mt-1">{dict[state.lang].suggestion}</p></>}
                </Card>}

              {state.mode==='pmt' &&
                <Card><p className="text-sm">{dict[state.lang].requiredPMT(requiredPMT ?? 0, state.currency)}</p></Card>}

              <ChartsPanel series={sim.data} t={dict[state.lang].charts} currency={state.currency}/>
            </section>
          </div>

          <footer className="mt-6 text-xs text-slate-500">
            <p>Les paramètres sont encodés dans l’URL. Rafraîchissez pour restaurer l’état.</p>
          </footer>
        </main>
      );
    }

    createRoot(document.getElementById('root')).render(<App/>);
  </script>
</body>
</html>

    root.render(<App />);
  </script>
</body>
</html>
