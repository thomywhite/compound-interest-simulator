<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simulateur d'Intérêts Composés</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            border: "hsl(var(--border))",
            input: "hsl(var(--input))",
            ring: "hsl(var(--ring))",
            background: "hsl(var(--background))",
            foreground: "hsl(var(--foreground))",
            primary: {
              DEFAULT: "hsl(var(--primary))",
              foreground: "hsl(var(--primary-foreground))",
            },
            secondary: {
              DEFAULT: "hsl(var(--secondary))",
              foreground: "hsl(var(--secondary-foreground))",
            },
            destructive: {
              DEFAULT: "hsl(var(--destructive))",
              foreground: "hsl(var(--destructive-foreground))",
            },
            muted: {
              DEFAULT: "hsl(var(--muted))",
              foreground: "hsl(var(--muted-foreground))",
            },
            accent: {
              DEFAULT: "hsl(var(--accent))",
              foreground: "hsl(var(--accent-foreground))",
            },
            popover: {
              DEFAULT: "hsl(var(--popover))",
              foreground: "hsl(var(--popover-foreground))",
            },
            card: {
              DEFAULT: "hsl(var(--card))",
              foreground: "hsl(var(--card-foreground))",
            },
          },
          borderRadius: {
            lg: "var(--radius)",
            md: "calc(var(--radius) - 2px)",
            sm: "calc(var(--radius) - 4px)",
          },
        },
      },
    }
  </script>
  <style>
    :root {
      --background: 0 0% 100%;
      --foreground: 222.2 84% 4.9%;
      --card: 0 0% 100%;
      --card-foreground: 222.2 84% 4.9%;
      --popover: 0 0% 100%;
      --popover-foreground: 222.2 84% 4.9%;
      --primary: 222.2 47.4% 11.2%;
      --primary-foreground: 210 40% 98%;
      --secondary: 210 40% 96.1%;
      --secondary-foreground: 222.2 47.4% 11.2%;
      --muted: 210 40% 96.1%;
      --muted-foreground: 215.4 16.3% 46.9%;
      --accent: 210 40% 96.1%;
      --accent-foreground: 222.2 47.4% 11.2%;
      --destructive: 0 84.2% 60.2%;
      --destructive-foreground: 210 40% 98%;
      --border: 214.3 31.8% 91.4%;
      --input: 214.3 31.8% 91.4%;
      --ring: 222.2 84% 4.9%;
      --radius: 0.5rem;
    }
    .dark {
      --background: 222.2 84% 4.9%;
      --foreground: 210 40% 98%;
      --card: 222.2 84% 4.9%;
      --card-foreground: 210 40% 98%;
      --popover: 222.2 84% 4.9%;
      --popover-foreground: 210 40% 98%;
      --primary: 210 40% 98%;
      --primary-foreground: 222.2 47.4% 11.2%;
      --secondary: 217.2 32.6% 17.5%;
      --secondary-foreground: 210 40% 98%;
      --muted: 217.2 32.6% 17.5%;
      --muted-foreground: 215 20.2% 65.1%;
      --accent: 217.2 32.6% 17.5%;
      --accent-foreground: 210 40% 98%;
      --destructive: 0 62.8% 30.6%;
      --destructive-foreground: 210 40% 98%;
      --border: 217.2 32.6% 17.5%;
      --input: 217.2 32.6% 17.5%;
      --ring: 212.7 26.8% 83.9%;
    }
    * {
      @apply border-border;
    }
    body {
      @apply bg-background text-foreground;
    }
  </style>
</head>
<body class="antialiased">
  <div id="root"></div>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/recharts/umd/Recharts.min.js"></script>
  <script src="https://unpkg.com/lucide-react@latest/dist/umd/lucide-react.min.js"></script>
  <script src="https://unpkg.com/framer-motion/dist/framer-motion.js"></script>
  <script src="https://unpkg.com/decimal.js/decimal.min.js"></script>
  <script type="text/babel">
    const { createElement: e, useState, useEffect, useMemo, Fragment } = React;
    const { motion } = framerMotion;
    const { LineChart, AreaChart, BarChart, Line, Area, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } = Recharts;
    const Decimal = window.Decimal;

    const i18n = {
      fr: {
        title: 'Simulateur d\'Intérêts Composés',
        mode1: 'Combien aurai-je ?',
        mode2: 'Combien de temps cela prendra-t-il ?',
        mode3: 'Combien dois-je contribuer ?',
        initialAmount: 'Montant initial (P0)',
        periodicContribution: 'Contribution périodique (PMT)',
        annualReturn: 'Rendement nominal annuel (r%)',
        fees: 'Frais (f%)',
        inflation: 'Inflation (infl%)',
        investmentHorizon: 'Horizon d\'investissement',
        years: 'Années',
        months: 'Mois',
        targetAmount: 'Montant cible (FV_target)',
        contributionFrequency: 'Fréquence des contributions',
        compoundingFrequency: 'Fréquence de composition',
        contributionTiming: 'Timing des contributions',
        start: 'Début de période',
        end: 'Fin de période',
        showTaxes: 'Afficher les taxes (placeholder)',
        finalBalance: 'Solde final',
        totalContributions: 'Contributions totales',
        totalGrowth: 'Croissance totale',
        effectiveAnnualRate: 'Taux annuel effectif (EAR)',
        realFinalBalance: 'Solde final réel (ajusté inflation)',
        balanceOverTime: 'Solde au fil du temps',
        breakdown: 'Répartition contributions vs croissance',
        summary: 'Résumé',
        presets: 'Préréglages',
        lumpSumOnly: 'Somme forfaitaire seulement',
        monthlyContributions: 'Contributions mensuelles',
        reset: 'Réinitialiser',
        copyLink: 'Copier le lien',
        exportCSV: 'Exporter CSV',
        language: 'Langue',
        currency: 'Devise',
        theme: 'Thème',
        unreachable: 'Cible inatteignable avec les paramètres actuels.',
        suggestRate: 'Taux requis : ',
        suggestPMT: 'Contribution requise : ',
        suggestTime: 'Temps supplémentaire : ',
        daily: 'Quotidien',
        weekly: 'Hebdomadaire',
        monthly: 'Mensuel',
        annually: 'Annuel',
      },
      en: {
        title: 'Compound Interest Simulator',
        mode1: 'How much will I have?',
        mode2: 'How long will it take?',
        mode3: 'How much should I contribute?',
        initialAmount: 'Initial amount (P0)',
        periodicContribution: 'Periodic contribution (PMT)',
        annualReturn: 'Annual nominal return (r%)',
        fees: 'Fees (f%)',
        inflation: 'Inflation (infl%)',
        investmentHorizon: 'Investment horizon',
        years: 'Years',
        months: 'Months',
        targetAmount: 'Target amount (FV_target)',
        contributionFrequency: 'Contribution frequency',
        compoundingFrequency: 'Compounding frequency',
        contributionTiming: 'Contribution timing',
        start: 'Start of period',
        end: 'End of period',
        showTaxes: 'Show taxes (placeholder)',
        finalBalance: 'Final balance',
        totalContributions: 'Total contributions',
        totalGrowth: 'Total growth',
        effectiveAnnualRate: 'Effective annual rate (EAR)',
        realFinalBalance: 'Real final balance (inflation-adjusted)',
        balanceOverTime: 'Balance over time',
        breakdown: 'Breakdown contributions vs growth',
        summary: 'Summary',
        presets: 'Presets',
        lumpSumOnly: 'Lump sum only',
        monthlyContributions: 'Monthly contributions',
        reset: 'Reset',
        copyLink: 'Copy link',
        exportCSV: 'Export CSV',
        language: 'Language',
        currency: 'Currency',
        theme: 'Theme',
        unreachable: 'Target unreachable with current params.',
        suggestRate: 'Required rate: ',
        suggestPMT: 'Required contribution: ',
        suggestTime: 'Extra time: ',
        daily: 'Daily',
        weekly: 'Weekly',
        monthly: 'Monthly',
        annually: 'Annually',
      },
    };

    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      while (b !== 0) {
        let temp = b;
        b = a % b;
        a = temp;
      }
      return a;
    }

    function lcm(a, b) {
      return Math.abs(a * b) / gcd(a, b);
    }

    function simulateCompound(params) {
      const { p0, pmt, r, f, contribFreq, compoundFreq, timing, totalYears } = params;
      const freqToPeriods = { Daily: 365, Weekly: 52, Monthly: 12, Annually: 1 };
      const contribPeriods = freqToPeriods[contribFreq];
      const compoundPeriods = freqToPeriods[compoundFreq];
      const periodsPerYear = lcm(contribPeriods, compoundPeriods);
      const compoundInterval = periodsPerYear / compoundPeriods;
      const contribInterval = periodsPerYear / contribPeriods;
      const rNet = Decimal(1).add(r).div(Decimal(1).add(f)).sub(1);
      const ratePerCompound = rNet.div(compoundPeriods);
      const totalSteps = Math.round(periodsPerYear * totalYears);
      let balance = Decimal(p0);
      let totalContrib = Decimal(0);
      const data = [];
      data.push({ time: 0, balance: balance.toNumber(), totalContrib: totalContrib.toNumber(), growth: balance.sub(totalContrib).toNumber() });
      for (let step = 1; step <= totalSteps; step++) {
        if (timing === 'start' && (step - 1) % contribInterval === 0) {
          balance = balance.add(pmt);
          totalContrib = totalContrib.add(pmt);
        }
        if (step % compoundInterval === 0) {
          balance = balance.mul(Decimal(1).add(ratePerCompound));
        }
        if (timing === 'end' && step % contribInterval === 0) {
          balance = balance.add(pmt);
          totalContrib = totalContrib.add(pmt);
        }
        const time = step / periodsPerYear;
        data.push({ time, balance: balance.toNumber(), totalContrib: totalContrib.toNumber(), growth: balance.sub(totalContrib).toNumber() });
      }
      return { data, finalBalance: balance, totalContrib, growth: balance.sub(totalContrib) };
    }

    function findTimeToTarget(params) {
      const { p0, pmt, r, f, contribFreq, compoundFreq, timing, target, maxYears = 100 } = params;
      const freqToPeriods = { Daily: 365, Weekly: 52, Monthly: 12, Annually: 1 };
      const contribPeriods = freqToPeriods[contribFreq];
      const compoundPeriods = freqToPeriods[compoundFreq];
      const periodsPerYear = lcm(contribPeriods, compoundPeriods);
      const compoundInterval = periodsPerYear / compoundPeriods;
      const contribInterval = periodsPerYear / contribPeriods;
      const rNet = Decimal(1).add(r).div(Decimal(1).add(f)).sub(1);
      const ratePerCompound = rNet.div(compoundPeriods);
      const maxSteps = periodsPerYear * maxYears;
      let step = 0;
      let balance = Decimal(p0);
      let totalContrib = Decimal(0);
      while (balance.lt(target) && step < maxSteps) {
        step++;
        if (timing === 'start' && (step - 1) % contribInterval === 0) {
          balance = balance.add(pmt);
          totalContrib = totalContrib.add(pmt);
        }
        if (step % compoundInterval === 0) {
          balance = balance.mul(Decimal(1).add(ratePerCompound));
        }
        if (timing === 'end' && step % contribInterval === 0) {
          balance = balance.add(pmt);
          totalContrib = totalContrib.add(pmt);
        }
      }
      const time = step / periodsPerYear;
      if (balance.lt(target)) {
        return { time: Infinity, message: 'Cible inatteignable dans 100 ans' };
      }
      return { time, finalBalance: balance, totalContrib };
    }

    function findRequiredPMT(params) {
      const { p0, r, f, contribFreq, compoundFreq, timing, totalYears, target } = params;
      const fv0 = simulateCompound({ ...params, pmt: 0 }).finalBalance;
      const fv1 = simulateCompound({ ...params, pmt: 1 }).finalBalance;
      const annuityFactor = fv1.sub(fv0);
      if (annuityFactor.eq(0)) {
        return Infinity;
      }
      const required = Decimal(target).sub(fv0).div(annuityFactor);
      return required;
    }

    function findRequiredRate(params) {
      const { totalYears, target } = params;
      let low = Decimal(0);
      let high = Decimal(1);
      for (let it = 0; it < 50; it++) {
        let mid = low.add(high).div(2);
        const { finalBalance } = simulateCompound({ ...params, r: mid.toNumber() });
        if (finalBalance.lt(target)) {
          low = mid;
        } else {
          high = mid;
        }
      }
      return low.toNumber() * 100;
    }

    // Unit tests
    function runUnitTests() {
      const testCases = [
        // 1. Lump sum only
        {
          name: 'Lump sum only',
          params: { p0: 10000, pmt: 0, r: 0.07, f: 0, contribFreq: 'Annually', compoundFreq: 'Annually', timing: 'end', totalYears: 20 },
          expectedFV: 10000 * Math.pow(1.07, 20),
        },
        // 2. PMT only
        {
          name: 'PMT only',
          params: { p0: 0, pmt: 200, r: 0.07, f: 0, contribFreq: 'Monthly', compoundFreq: 'Monthly', timing: 'end', totalYears: 20 },
          expectedFV: 200 * (Math.pow(1 + 0.07/12, 20*12) - 1) / (0.07/12),
        },
        // 3. Mixed with monthly compounding
        {
          name: 'Mixed monthly',
          params: { p0: 10000, pmt: 200, r: 0.07, f: 0, contribFreq: 'Monthly', compoundFreq: 'Monthly', timing: 'end', totalYears: 20 },
          expectedFV: 10000 * Math.pow(1 + 0.07/12, 20*12) + 200 * (Math.pow(1 + 0.07/12, 20*12) - 1) / (0.07/12),
        },
        // 4. Negative/zero rate
        {
          name: 'Negative rate',
          params: { p0: 10000, pmt: 0, r: -0.01, f: 0, contribFreq: 'Annually', compoundFreq: 'Annually', timing: 'end', totalYears: 20 },
          expectedFV: 10000 * Math.pow(0.99, 20),
        },
        // 5. Time to goal with PMT
        {
          name: 'Time to goal',
          params: { p0: 10000, pmt: 200, r: 0.07, f: 0, contribFreq: 'Monthly', compoundFreq: 'Monthly', timing: 'end', target: 100000 },
          expectedTime: Math.log((100000 * (0.07/12) + 200) / (10000 * (0.07/12) + 200)) / Math.log(1 + 0.07/12) / 12,
        },
      ];

      testCases.forEach(test => {
        if (test.expectedFV) {
          const { finalBalance } = simulateCompound(test.params);
          console.log(test.name, 'FV:', finalBalance.toNumber(), 'Expected:', test.expectedFV, 'Pass:', Math.abs(finalBalance.toNumber() - test.expectedFV) < 1);
        } else if (test.expectedTime) {
          const { time } = findTimeToTarget(test.params);
          console.log(test.name, 'Time:', time, 'Expected:', test.expectedTime, 'Pass:', Math.abs(time - test.expectedTime) < 0.1);
        }
      });
    }

    // Call runUnitTests() in console to run tests

    const defaults = {
      mode: 'mode1',
      p0: 10000,
      pmt: 200,
      r: 7,
      f: 0.5,
      infl: 2,
      years: 20,
      months: 0,
      fvTarget: 100000,
      contribFreq: 'Monthly',
      compoundFreq: 'Monthly',
      timing: 'end',
      showTaxes: false,
      lang: 'fr',
      theme: 'light',
      currency: '$',
    };

    const App = () => {
      const [searchParams, setSearchParams] = useState(new URLSearchParams(window.location.search));
      const [state, setState] = useState({ ...defaults });
      const [debouncedState, setDebouncedState] = useState(state);
      const [darkMode, setDarkMode] = useState(false);

      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const newState = {};
        for (const key in defaults) {
          const value = params.get(key);
          if (value !== null) {
            newState[key] = isNaN(Number(value)) ? value : Number(value);
          }
        }
        setState({ ...defaults, ...newState });
      }, []);

      useEffect(() => {
        const timer = setTimeout(() => setDebouncedState(state), 300);
        return () => clearTimeout(timer);
      }, [state]);

      useEffect(() => {
        const params = new URLSearchParams();
        for (const key in state) {
          params.set(key, state[key]);
        }
        window.history.replaceState(null, '', '?' + params.toString());
      }, [state]);

      useEffect(() => {
        if (state.theme === 'dark') {
          document.body.classList.add('dark');
          setDarkMode(true);
        } else {
          document.body.classList.remove('dark');
          setDarkMode(false);
        }
      }, [state.theme]);

      const t = i18n[state.lang];

      const totalYears = state.years + state.months / 12;

      const currencyFormat = new Intl.NumberFormat(state.lang === 'fr' ? 'fr-FR' : 'en-US', { style: 'currency', currency: 'USD' });

      const params = {
        p0: state.p0,
        pmt: state.pmt,
        r: state.r / 100,
        f: state.f / 100,
        contribFreq: state.contribFreq,
        compoundFreq: state.compoundFreq,
        timing: state.timing,
        totalYears,
      };

      let result, data, finalBalance, totalContrib, growth, ear, realFV, message, suggestions;

      const rNet = (1 + params.r) / (1 + params.f) - 1;

      ear = Math.pow(1 + rNet / freqToPeriods[state.compoundFreq], freqToPeriods[state.compoundFreq]) - 1;

      if (state.mode === 'mode1') {
        result = simulateCompound(params);
        data = result.data;
        finalBalance = result.finalBalance;
        totalContrib = result.totalContrib;
        growth = result.growth;
        realFV = finalBalance.div(Math.pow(1 + state.infl / 100, totalYears));
      } else if (state.mode === 'mode2') {
        const target = state.fvTarget;
        result = findTimeToTarget({ ...params, target });
        if (result.time === Infinity) {
          message = t.unreachable;
          // Suggestions
          suggestions = {};
          suggestions.requiredRate = findRequiredRate({ ...params, totalYears: 20, target });
          suggestions.requiredPMT = findRequiredPMT({ ...params, totalYears: 20, target });
          suggestions.extraTime = findTimeToTarget({ ...params, r: params.r + 0.05, target }).time - 20;
        } else {
          const years = Math.floor(result.time);
          const months = Math.round((result.time - years) * 12);
          message = `${years} ${t.years} ${months} ${t.months}`;
          finalBalance = result.finalBalance;
          totalContrib = result.totalContrib;
          growth = finalBalance.sub(totalContrib);
          realFV = finalBalance.div(Math.pow(1 + state.infl / 100, result.time));
        }
      } else if (state.mode === 'mode3') {
        const target = state.fvTarget;
        const requiredPMT = findRequiredPMT({ ...params, target: state.fvTarget });
        if (requiredPMT === Infinity || requiredPMT.lt(0)) {
          message = t.unreachable;
          // Suggestions
          suggestions = {};
          suggestions.requiredRate = findRequiredRate({ ...params, target });
          suggestions.extraTime = findTimeToTarget({ ...params, totalYears: totalYears + 10, target }).time - totalYears;
        } else {
          message = currencyFormat.format(requiredPMT.toNumber());
          // Run simulation with required PMT
          result = simulateCompound({ ...params, pmt: requiredPMT.toNumber() });
          data = result.data;
          finalBalance = result.finalBalance;
          totalContrib = result.totalContrib;
          growth = result.growth;
          realFV = finalBalance.div(Math.pow(1 + state.infl / 100, totalYears));
        }
      }

      const handleInput = (key, value) => {
        setState(prev => ({ ...prev, [key]: value }));
      };

      const handlePreset = (preset) => {
        let newState;
        if (preset === 'lumpSumOnly') {
          newState = { ...defaults, pmt: 0 };
        } else if (preset === 'monthlyContributions') {
          newState = { ...defaults };
        }
        setState(newState);
      };

      const handleReset = () => {
        setState({ ...defaults });
      };

      const handleCopyLink = () => {
        navigator.clipboard.writeText(window.location.href);
      };

      const handleExportCSV = () => {
        if (!data) return;
        const csv = 'time,balance,totalContrib,growth\n' + data.map(row => `${row.time},${row.balance},${row.totalContrib},${row.growth}`).join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'simulation.csv';
        a.click();
      };

      const freqOptions = ['Daily', 'Weekly', 'Monthly', 'Annually'];

      const ModeTabs = () => (
        e('div', { className: 'flex space-x-1 rounded-xl bg-secondary p-1' },
          ['mode1', 'mode2', 'mode3'].map(m => (
            e('button', {
              key: m,
              className: `w-full rounded-lg py-2.5 text-sm font-medium leading-5 text-primary ${state.mode === m ? 'bg-background shadow' : 'hover:bg-accent'}`,
              onClick: () => handleInput('mode', m),
            }, t[m])
          ))
        )
      );

      const SegmentedControl = ({ value, onChange, options }) => (
        e('div', { className: 'flex space-x-1 rounded-xl bg-secondary p-1' },
          options.map(opt => (
            e('button', {
              key: opt,
              className: `w-full rounded-lg py-2.5 text-sm font-medium leading-5 text-primary ${value === opt ? 'bg-background shadow' : 'hover:bg-accent'}`,
              onClick: () => onChange(opt),
            }, t[opt.toLowerCase()])
          ))
        )
      );

      const InputWithSlider = ({ label, value, onChange, min, max, step, type = 'number' }) => (
        e('div', { className: 'space-y-2' },
          e('label', { className: 'text-sm font-medium' }, label),
          e('input', { type, value, onChange: e => onChange(type === 'number' ? Number(e.target.value) : e.target.value), className: 'w-full p-2 border rounded' , min, max, step }),
          e('input', { type: 'range', value, onChange: e => onChange(Number(e.target.value)), min, max, step, className: 'w-full' })
        )
      );

      const KpiCard = ({ title, value }) => (
        e(motion.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, className: 'p-4 border rounded-lg shadow bg-card text-card-foreground' },
          e('h3', { className: 'text-sm font-medium' }, title),
          e('p', { className: 'text-2xl font-bold' }, value)
        )
      );

      const Chart = ({ title, children }) => (
        e('div', { className: 'p-4 border rounded-lg shadow bg-card' },
          e('h3', { className: 'text-sm font-medium mb-2' }, title),
          e(ResponsiveContainer, { width: '100%', height: 300 }, children)
        )
      );

      return e(Fragment, null,
        e('header', { className: 'flex justify-between items-center p-4 border-b' },
          e('h1', { className: 'text-2xl font-bold' }, t.title),
          e('div', { className: 'flex space-x-2' },
            e('select', { value: state.lang, onChange: e => handleInput('lang', e.target.value), className: 'p-2 border rounded' },
              e('option', { value: 'fr' }, 'Français'),
              e('option', { value: 'en' }, 'English')
            ),
            e('select', { value: state.currency, onChange: e => handleInput('currency', e.target.value), className: 'p-2 border rounded' },
              e('option', { value: '$' }, '$ USD')
            ),
            e('button', { onClick: () => handleInput('theme', state.theme === 'light' ? 'dark' : 'light'), className: 'p-2 border rounded' },
              state.theme === 'light' ? 'Dark' : 'Light'
            )
          )
        ),
        e('div', { className: 'flex flex-col md:flex-row p-4 space-y-4 md:space-y-0 md:space-x-4' },
          e('div', { className: 'w-full md:w-1/3 space-y-4' },
            e(ModeTabs),
            e('div', { className: 'space-y-4' },
              e(InputWithSlider, { label: t.initialAmount, value: state.p0, onChange: v => handleInput('p0', v), min: 0, max: 1000000, step: 100 }),
              e(InputWithSlider, { label: t.periodicContribution, value: state.pmt, onChange: v => handleInput('pmt', v), min: 0, max: 10000, step: 10 }),
              e(InputWithSlider, { label: t.annualReturn, value: state.r, onChange: v => handleInput('r', v), min: -10, max: 20, step: 0.1 }),
              e(InputWithSlider, { label: t.fees, value: state.f, onChange: v => handleInput('f', v), min: 0, max: 5, step: 0.1 }),
              e(InputWithSlider, { label: t.inflation, value: state.infl, onChange: v => handleInput('infl', v), min: 0, max: 10, step: 0.1 }),
              (state.mode === 'mode1' || state.mode === 'mode3') && e('div', { className: 'space-y-2' },
                e('label', { className: 'text-sm font-medium' }, t.investmentHorizon),
                e('div', { className: 'flex space-x-2' },
                  e('input', { type: 'number', value: state.years, onChange: e => handleInput('years', Number(e.target.value)), className: 'w-1/2 p-2 border rounded', min: 0 }),
                  e('span', null, t.years),
                  e('input', { type: 'number', value: state.months, onChange: e => handleInput('months', Number(e.target.value)), className: 'w-1/2 p-2 border rounded', min: 0, max: 11 }),
                  e('span', null, t.months)
                )
              ),
              (state.mode === 'mode2' || state.mode === 'mode3') && e(InputWithSlider, { label: t.targetAmount, value: state.fvTarget, onChange: v => handleInput('fvTarget', v), min: 0, max: 10000000, step: 1000 }),
              e('div', { className: 'space-y-2' },
                e('label', { className: 'text-sm font-medium' }, t.contributionFrequency),
                e(SegmentedControl, { value: state.contribFreq, onChange: v => handleInput('contribFreq', v), options: freqOptions })
              ),
              e('div', { className: 'space-y-2' },
                e('label', { className: 'text-sm font-medium' }, t.compoundingFrequency),
                e(SegmentedControl, { value: state.compoundFreq, onChange: v => handleInput('compoundFreq', v), options: freqOptions })
              ),
              e('div', { className: 'space-y-2' },
                e('label', { className: 'text-sm font-medium' }, t.contributionTiming),
                e(SegmentedControl, { value: state.timing, onChange: v => handleInput('timing', v), options: ['start', 'end'] })
              ),
              e('div', { className: 'flex items-center space-x-2' },
                e('input', { type: 'checkbox', checked: state.showTaxes, onChange: e => handleInput('showTaxes', e.target.checked) }),
                e('label', { className: 'text-sm' }, t.showTaxes)
              )
            )
          ),
          e('div', { className: 'w-full md:w-2/3 space-y-4' },
            message && e('p', { className: 'text-destructive' }, message),
            suggestions && e('div', { className: 'space-y-2' },
              e('p', null, t.suggestRate, suggestions.requiredRate.toFixed(2), '%'),
              e('p', null, t.suggestPMT, currencyFormat.format(suggestions.requiredPMT.toNumber())),
              e('p', null, t.suggestTime, suggestions.extraTime.toFixed(1), ' années')
            ),
            e('div', { className: 'grid grid-cols-1 md:grid-cols-3 gap-4' },
              e(KpiCard, { title: t.finalBalance, value: finalBalance ? currencyFormat.format(finalBalance.toNumber()) : '-' }),
              e(KpiCard, { title: t.totalContributions, value: totalContrib ? currencyFormat.format(totalContrib.toNumber()) : '-' }),
              e(KpiCard, { title: t.totalGrowth, value: growth ? currencyFormat.format(growth.toNumber()) : '-' }),
              e(KpiCard, { title: t.effectiveAnnualRate, value: (ear * 100).toFixed(2) + '%' }),
              e(KpiCard, { title: t.realFinalBalance, value: realFV ? currencyFormat.format(realFV.toNumber()) : '-' })
            ),
            data && e(Chart, { title: t.balanceOverTime },
              e(LineChart, { data },
                e(CartesianGrid, { strokeDasharray: "3 3" }),
                e(XAxis, { dataKey: "time" }),
                e(YAxis),
                e(Tooltip),
                e(Legend),
                e(Line, { type: "monotone", dataKey: "balance", stroke: "#8884d8" })
              )
            ),
            data && e(Chart, { title: t.breakdown },
              e(AreaChart, { data },
                e(CartesianGrid, { strokeDasharray: "3 3" }),
                e(XAxis, { dataKey: "time" }),
                e(YAxis),
                e(Tooltip),
                e(Legend),
                e(Area, { type: "monotone", dataKey: "totalContrib", stackId: "1", stroke: "#8884d8", fill: "#8884d8" }),
                e(Area, { type: "monotone", dataKey: "growth", stackId: "1", stroke: "#82ca9d", fill: "#82ca9d" })
              )
            ),
            data && e(Chart, { title: t.summary },
              e(BarChart, { data: [{ contrib: totalContrib.toNumber(), growth: growth.toNumber() }] },
                e(CartesianGrid, { strokeDasharray: "3 3" }),
                e(XAxis, { dataKey: "name" }),
                e(YAxis),
                e(Tooltip),
                e(Legend),
                e(Bar, { dataKey: "contrib", fill: "#8884d8" }),
                e(Bar, { dataKey: "growth", fill: "#82ca9d" })
              )
            )
          )
        ),
        e('footer', { className: 'p-4 border-t flex justify-between' },
          e('select', { onChange: e => handlePreset(e.target.value), className: 'p-2 border rounded' },
            e('option', null, t.presets),
            e('option', { value: 'lumpSumOnly' }, t.lumpSumOnly),
            e('option', { value: 'monthlyContributions' }, t.monthlyContributions)
          ),
          e('div', { className: 'space-x-2' },
            e('button', { onClick: handleReset, className: 'p-2 border rounded' }, t.reset),
            e('button', { onClick: handleCopyLink, className: 'p-2 border rounded' }, t.copyLink),
            e('button', { onClick: handleExportCSV, className: 'p-2 border rounded' }, t.exportCSV)
          )
        )
      );
    };

    ReactDOM.render(e(App), document.getElementById('root'));
  </script>
</body>
</html>

  </script>
</body>
</html>
